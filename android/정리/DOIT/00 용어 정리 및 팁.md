# 용어 정리

# 01

### chap 02

#### 02-1

- **안드로이드 스튜디오**(02-1, 19p) : 자바(java)로 만들어진 Intellij 기반의 개발 도구이며, 안드로이드를 개발할 때 사용한다
- **안드로이드 플랫폼**(02-1, 24p) : 버전별로 만들어진 실행 환경이다
  - PC에서는 에뮬레이터, 실제 단말에서는 단말의 OS이다
  - AVD(Android Virtual Device); 안드로이드 가상 단말, 안드로이드에서 사용하는 가상의 플랫폼이다



### chap 03

#### 03-1

- **Blueprint**(03-1, 31p) : 청사진, 화면 안의 요소가 서로 겹쳐 있을 때, 요소를 투명하게 보여주어 어떤 것들이 어떤 모양으로 들어 있는지 알 수 있다
  - 버튼, 글자 요소가 서로 겹쳐 있다면 Design 화면에서는 가장 위에 있는 요소만 보이지만, Blueprint 화면에서는 겹친 두 요소가 모두 보인다

---

#### 03-3

- **onCreate**(03-3, 38p) : 해당 Activity가 처음 실행될 때 가장 먼저 호출되는 메소드, 자바의 main 메소드와 비슷한 개념이다

  ```java
  protected void onCreate(Bundle savedInstanceState) {}
  ```

- **super**(03-3, 38p) : 상속을 받는 자식 클래스에서 부모 클래스에게 현재 작업의 정보를 전달해주는 것이다

  ```java
  super.onCreate(savedInstanceState);
  ```

- **setContentView**(03-3, 38p) : 화면에 무엇을 보여줄 것인지 설정해주는 함수(메소드)이다

  ```java
  setContentView(R.layout.activity_main);
  ```

  - 위의 코드에서는 `activity_main`이라는 레이아웃을 보여준다
  - `R.layout.activity_main` : 화면이 사용자에게 어떻게 보일지 결정하는 xml 파일의 위치를 지정한다

- **activity_main.xml**(03-3, 40p) : 앱을 실행했을 때 나타나는 첫 화면의 모든 정보(구성 요소, 모양)를 담고 있다

- **textView**(03-3, 41p) : 글자를 화면에 보여주는 View이다

- **Button**(03-3, 43, 80p) : 앱을 사용하는 사람이 무언가를 실행하게 해주는 View이다,

  - 버튼을 누르는 이벤트를 *클릭 이벤트*라고 하며, 직접 코드를 입력하여 어떻게 동작할지 결정해 준다

  ```xml
  <Button
      android:id="@+id/button"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content">
  ```

  - 위의 코드는 `button`이라는 id를 가진 Button을 구성하는 코드이다
  - TextView를 상속받아 TextView의 속성을 그대로 가지고 있다

- **Toast**(03-3, 46p) : 작고 간단한 메시지를 잠깐 보여주는 역할을 한다

  ```java
  Toast.makeText(this, "fine!", Toast.LENGTH_SHORT).show();
  ```

  - 위의 코드는 `fine`이라는 문자열을 출력하는 Toast 메시지이다
    - `Toast.LENGTH_SHORT`부분은 Toast 메시지 표시 시간의 길이를 나타내며, `LENGTH_SHORT` 외에도 `LENGTH_LONG`이 있다

- **onClick**(03-3, 47p) : 해당 view가 눌러졌을 때 발생하는 이벤트이며, *클릭 이벤트*이다

---

#### 03-4

- **Intent**(3-4, 53p ~ 54p) : 어떤 기능을 실행할 것인지 지정할 때 사용한다

  - 안드로이드 플랫폼에게 원하는 것을 말할 때 전달하는 우편물 같은 것이다
  - Intent를 사용하면 앱을 구성하는 화면을 새로 띄우거나 화면 간에 데이터 전달을 할 수 있다

  ```java
  public void onButton1Clicked(View v) {
      //intent 선언
      Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://m.naver.com"));
      //intent 실행
      startActivity(myIntent);
      }
  ```

  - 위의 코드는 `Button1` View가 클릭되었을 때 `myIntent`라는 Intent 변수를 실행시켜 `http://m.naver.com`링크를 브라우저에서 띄우는 코드이다



## 02

### chap 01

#### 01-2

- 화면의 구성(01-2, 80p) : 크게 View와 ViewGroup으로 나눌 수 있다

  - **View**(01-2, 79~?p) : 화면을 구성하는 기본 요소이며, 사용자의 눈에 보이는 각각의 요소를 말한다
    - 일반적으로 컨트롤, 또는 위젯이라고 불린다
    - 다른 View의 속성을 상속받아, 상속받은 View의 특성을 그대로 가질 수 있다
    - 모든 View는 반드시 크기 속성이 존재해야 한다

  - **ViewGroup**(01-2, 79~80p) : View를 여러 개 포함하고 있는 것을 말한다
    - ViewGroup 내에서 View의 위치를 지정할 수 있다
    - View를 상속하여 만들어졌기 때문에, ViewGroup 안에는 View 외에도 또다른 ViewGroup을 포함할 수 있다


- **Composite Pattern**(01-2, 80p) : 디자인 패턴 중 하나이며, Composite Pattern으로 만들어진 ViewGroup은 뛰어난 확장성을 가진다
- **View**의 구분
  - **Widget**(01-2, 80p) : View들 중, 화면에 보이면서 일반적인 컨트롤의 역할을 하는 것이다
  - **Layout**(01-2, 80~81p) : ViewGroup 중, 내부에 View들을 포함하고 있으면서 그것들을 배치하는 역할을 하는 것이다
    - 한 Layout 내에 다른 Layout들을 포함시킬 수 있다
- View의 크기

  - 크기 속성

    - **layout_width**(01-2. 83p) : View의 필수 설정이며, 해당 뷰의 폭(가로)의 크기를 설정한다
    - **layout_height**(01-2, 83p) : View의 필수 설정이며, 해당 뷰의 높이(세로)의 크기를 설정한다
  - 속성의 값
  
    - **wrap_content**(01-2, 84p) : 뷰 내부의 내용물의 크기에 자동으로 맞춘다
    - **match_parent**(01-2, 84p) : 뷰를 포함하는 부모 뷰그룹의 전체 크기에 맞춘다
    - 숫자로 크기 지정 : 유동적인 wrap_content, match_parent와 다르게 고정된 값이며, dp, dx 등 단위를 포함해야 한다

---


#### 01-3


- **ConstraintLayout**(01-3, 88p) : View의 위치를 결정할 때, 제약 조건(Constraint)를 사용한다

  - **Constraint**(01-3, 88p) : View가 Layout 내 다른 요소와 어떻게 연결되는지 알려주는 것이다

    - View의 연결점(Anchor Point)와 대상(Target)을 연결한다

    - View의 위치를 결정하려면 적어도 왼쪽과 위쪽에는 연결되어 있어야 한다
      다음 목록 등이 연결 대상이 될 수 있다

      - 같은 부모 레이아웃 안에 들어 있는 뷰의 연결점
      - 부모 레이아웃의 연결점
      - Guideline(가이드라인)

      다음 목록 등이 연결점이 될 수 있다

      - Top(위쪽), Bottom(아래쪽), Left(또는 'Start', 왼쪽), Right(또는 'End', 오른쪽)
      - 가로축의 가운데(CenterX), 세로축의 가운데(CenterY)
      - 텍스트를 포함한 View의 경우, 다른 뷰의 텍스트의 높이/위치를 기준으로 하는 Baseline(베이스라인)

- **Margin**(01-3, 90p) : Anchor Point와 Target 사이 두게 할 간격의 값이다

- **bias**(01-3, 92~93p) : 화면을 비율로 나눈 후 어느 곳에 위치시킬지를 결정하는 값이며, 단위는 백분율(%)이다
  - **vertical_bias**(01-3, 92p) : 세로 방향 bias의 속성을 정하며, 기본값은 50이다
  - **horizontal_bias**(01-3, 92p) : 가로 방향 bias의 속성을 정하며, 기본값은 50이다

- **Guideline**(01-3, 96p) :  여러 개의 View를 정렬할 때 사용하는 일정한 기준선이며, View처럼 화면에 추가할 수 있다

- **android:id**(01-3, 100p) : View를 구분하는 구분자 역할을 하며, 해당 View를 자바 소스 파일에서 찾을 때도 사용한다

- **layout_constraint**(01-3, 100p) : 하나의 View를 다른 View와 연결할 때 사용한다

  - Source View(01-3, 100p) : 두 View가 있을 때, 연결을 하는 View이다
  - Target View(01-3, 100p) : 두 View가 있을 때, 연결을 당하는 View이다

- **android:orientation**(01-3, 102p) : 레이아웃에서 가로 또는 세로로 정렬할 때 사용한다
  - vertical : 세로 방향으로 정렬한다
  - horizontal : 가로 방향으로 정렬한다

- **constraintGuide**(01-3, 102p) : 부모 레이아웃의 벽면에서 얼마나 떨어뜨려 배치할지 지정하는 속성 중 하나이다
  - **layout_constraintGuide_begin** : 세로 방향인 경우 왼쪽부터, 가로 방향인 경우 위쪽부터 거리를 지정한다
    - **layout_constraintGuide_percent** : begin 속성 대신 지정하며, % 단위로 지정한다
  - **layout_constraintGuide_end** : 세로 방향인 경우 오른쪽부터, 가로 방향인 경우 아래쪽부터 거리를 지정한다

- 크기를 표시하는 단위(01-3, 102p)
  - px(픽셀) : 화면의 픽셀 수
  - dp/dip(밀도 독립적 픽셀) : 160dpi(1인치 당 160개의 픽셀)인 화면을 기준으로 한 픽셀 (보통 View에 사용한다)
    - 해상도에 비례하는 비슷한 크기로 보이게 한다(160dpi에서 20픽셀인 뷰 :arrow_right: 320dpi에서 40픽셀인 뷰)
    - 해상도별로 일일이 크기를 다시 지정하지 않아도 된다
  - sp/sip(축척 독립적 픽셀) : 텍스트 크기를 지정할 때 사용하는 단위, dp와 유사하나 가변 글꼴을 기준으로 하였기에 1sp당 픽셀 수가 달라진다 (보통 Text속성이 있는 View에 사용한다)
  - in(인치) : 1인치의 물리적 길이
  - mm(밀리미터) : 1밀리미터의 물리적 길이
  - em(텍스트 크기) : 글꼴과 상관없이 동일한 텍스트 크기 표시
-  **margin**(01-3, 104p, 113p) : View의 다른 View 사이의 여백을 지정하며,  테두리 바깥쪽 공간이다
  
  - layout_marginTop : View의 위쪽의 여백을 지정한다
  - layout_marginBottom : View의 아래쪽 여백을 지정한다
  - layout_marginLeft : View의 왼쪽 여백을 지정한다
  - layout_marginRight : View의 오른쪽 여백을 지정한다
  - layout_margin : View의 모든 방향 여백을 지정한다

### chap 02

#### 02-1 LinearLayout

- 레이아웃의 종류(02-1, 109~110p)
  - Layout또한 모두 View이다
  - **ConstraintLayout**, 제약 레이아웃
    - 제약 조건을 사용하여 View를 배치하는 Constraint 기반 모델이다
    - 연결선을 제약 조건으로 하여 화면을 구성한다
    - 안드로이드 스튜디오의 기본 레이아웃이다
  - **LinearLayout**, 리니어(선형) 레이아웃
    - 한 쪽 방향으로 View를 쌓아가는 Box 모델이다
    - 일정 방향으로 차례대로 View를 추가하여 화면을 구성한다
      - 일정 방향으로 View를 추가하기 때문에, orientation(방향)을 지정해 주어야 한다
    - View가 차지할 수 있는 사각형의 영역을 할당한다
  - **RelativeLayout**, 상대 레이아웃
    - Rule 기반 모델이다
    - 부모 container 또는 다른 View와 상대적인 위치로 화면을 구성한다
    - RelativeLayout보다 ConstraintLayout 사용을 권장한다
  - **FrameLayout**, 프레임 레이아웃
    - Single 모델이다
    - 가장 상위에 있는 하나의 View 또는 View그룹만 보여주어 화면을 구성한다
    - 여러 개의 View가 들어가면 중첩하여 쌓인다
    - 여러 개의 View를 중첩한 후 각 View를 가장 위쪽의 위치로 전환하여 보여주는 방식을 사용한다
  - **TableLayout**, 테이블 레이아웃
    - Grid 모델이다
    - 격자 모양의 배열을 사용하여 화면을 구성한다
    - HTML에서 많이 사용하는 정렬 방식과 유사하지만, ConstraintLayout LinearLayout으로 대체될 수 있기 때문에, 많이 사용하지 않는다
- **ScrollView**(02-1, 112p) : View나 ViewGroup에 넣을 수 있고, 해당 View의 내용물이 넘치면 스크롤을 만들 수 있게 도와준다
  - View를 배치하는 목적을 가진 Layout이라기보다는 ViewGroup의 역할에 더 가깝다

- **Box**(02-1, 112p) : View의 영역 이라고도 하며, View가 Layout에 추가될 때는 보이지 않는 View의 테두리(Border/경계선)가 있다

- **padding**(02-1, 113p) : 테두리 안쪽 공간이다
  - 종류
    - paddingTop : content와 View 사이 위쪽의 여백을 지정한다
    - paddingBottom : content와 View 사이 아래쪽의 여백을 지정한다
    - paddingLeft : content와 View 사이 왼쪽의 여백을 지정한다
    - paddingRight : content와 View 사이 오른쪽의 여백을 지정한다
    - padding : content와 View 사이 모든 방향의 여백을 지정한다

- **content**(02-1, 113p) : Button, Text 등의 View의 내용물을 의미한다
- **background**(02-1, 113p) : 배경을 어떻게 그릴 지 지정하는 속성이다
  - background 속성을 설정하면 View가 화면에 그려질 때, 배경을 먼저 그리게 된다
  - background 속성을 색상으로 지정할 수 있다 (예 : RGB(#AARRGGBB-16진수) 등)
  - background 속성을 이미지로 지정할 수 있다

---

### chap 02

#### 02-2

- **LinearLayout**(02-2) : 한 방향으로만 View를 쌓는 Layout이며, orientation으로 방향을 설정해 주어야 한다

- Java 소스 코드로 Layout  구성
  - **LayoutParams**(02-2, 123p) : 자바 소스 코드에서 부모 Layout 내부에 View를 만들 때,  해당 View가 어떻게 배치될지 정의하는 속성이다
    - Layout에 추가되는 View의 속성 중에서 Layout과 관련된 속성을 담고 있다
    - LayoutParams 객체를 새로 만들 경우에는 반드시 View의 가로와 세로 속성을 지정해야 한다
      - LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT, 또는 직접 상수를 설정할 수 있다
  - **addView**(02-2, 123p) : 자바 소스 코드에서 Layout에 View를 추가할 때 사용하는 메소드이다

- LinearLayout의 View 정렬(02-2, 123p) : 어느 쪽에 View의 무게중심을 놓는지의 의미이다
  - LinearLayout에 포함되어 있는 View는 왼쪽, 가운데, 오른쪽 등의 방향을 지정하여 정렬할 수 있다
    - **layout_gravity**(02-2, 123~124p) : 부모 View에 여유 공간이 생겼을 때, 여유 공간 내부에서 View를 정렬한다
    
      - 해당 View 외부를 기준으로 View를 정렬한다
    
    - **gravity**(02-2, 123~124p) : View 내부의 내용물을 정렬함
    
      - TextView의 경우 내용물은 Text가 되며, ImageView의 경우 내용물은 Image가 된다
      - layout_width/layout_height의 크기를 wrap_content로 지정하면, View 내부 공간이 없어지기 때문에, gravity 속성을 사용할 수 없다
    
    - 정렬 속성값(02-2, 127p)
    
      | 속성값            | 설명                                                         |
      | ----------------- | ------------------------------------------------------------ |
      | top               | 대상 객체를 위쪽 끝에 배치한다                               |
      | bottom            | 대상 객체를 아래쪽 끝에 배치한다                             |
      | left/start        | 대상 객체를 왼쪽 끝에 배치한다                               |
      | right/end         | 대상 객체를 오른쪽 끝에 배치한다                             |
      | center_vertical   | 대상 객체를 수직 방향의 중앙에 배치한다                      |
      | center_horizontal | 대상 객체를 수평 방향의 중앙에 배치한다                      |
      | fill_vertical     | 대상 객체를 수직 방향의 여유 공간만큼 확대하여 채운다        |
      | fill_horizontal   | 대상 객체를 수평 방향의 여유 공간만큼 확대하여 채운다        |
      | center            | 대상 객체를 수직 방향과 수평 방향의 정중앙에 배치한다        |
      | fill              | 대상 객체를 수직 방향과 수평 방향으로 여유 공간만큼 확대하여 채운다 |
      | clip_vertical     | 대상 객체의 상하 길이가 여유 공간보다 클 경우, 남는 부분을 잘라내 배치한다<br />bottom\|clip_vertical : 위쪽의 남는 부분을 잘라낸다<br />top\|clip_vertical : 아래쪽의 남는 부분을 잘라낸다<br />center_vertical\|clip_vertical : 위쪽과 아래쪽의 남는 부분을 잘라낸다 |
      | clip_horizontal   | 대상 객체의 좌우 길이가 여유 공간보다 클 경우, 남는 부분을 잘라내 배치한다<br />right\|clip_horizontal : 왼쪽의 남는 부분을 잘라낸다<br />left\|clip_horizontal : 오른쪽의 남는 부분을 잘라낸다<br />center_horizontal : 왼쪽과 오른쪽의 남는 부분을 잘라낸다 |
    
    - **baselineAligned**(02-2, 128p) : button, textView 등의 문자의 baseline(글자의 가장 밑 부분)에 맞추어 일렬로 정렬하는 속성이다
    
      - 기본적으로 "true"로 설정되어 있으며, false로 변경 시 정렬하지 않는다

- **Cell**(02-2, 128p) : Widget Cell이라고도 하며, View의 테두리 선 기준으로 안쪽과 바깥쪽의 공간을 모두 포함하는 범위이다
  - margin : 테두리 바깥쪽 공간을 의미한다
    - `layout_margin` 속성을 사용한다
  - padding : 테두리 안쪽 공간을 의미한다
    - `padding` 속성을 사용한다
- **layout_weight**(02-2, 132p) : 부모 Layout에 추가한 View들의 공간을 제외한 여유 공간을 각 View에 분할한다
  - layout_weight에 특정 숫자 값을 넣어 분할 비율을 지정한 뒤, 그 빈율만큼 여유 공간을 분할한 후 해당되는 View에 할당한다
  - layout_weight를 사용할 때, layout_width 또는 layout_height에 지정하는 값은 wrap_content 또는 상수 값으로 지정해 주어야 한다
    - match_parent를 사용하면, 해당 View가 부모 View의 모든 공간을 차지하기 때문에 할당해 줄 공간이 없기 때문에, 사용해선 안된다
  - 부모 View의 전체 공간에서 분할하고 싶다면 자식 View의 `layout_width`를 0으로 설정해야 한다

---

#### 02-3 RelativeLayout

- **RelativeLayout**(02-3, 135p) : 상대 레이아웃이라고 부르며, 부모 Container, 또는 다른 View와의 상대적인 위치를 이용해 View의 위치를 결정한다

  - RelativeLayout 부모 View와의 상대적 정렬, 속성값 뒤에 `="true"` 또는 `="false"`로 활성화/비활성화 할 수 있다.

    | 속성값                                         | 설명값                                           |
    | ---------------------------------------------- | ------------------------------------------------ |
    | layout_alignParentTop                          | 부모 컨테이너 위쪽과 View의 위쪽을 맞춘다        |
    | layout_alignParentBottom                       | 부모 컨테이너 아래쪽과 View의 아래쪽을 맞춘다    |
    | layout_alignParentLeft/layout_alignParentStart | 부모 컨테이너의 왼쪽과 View의 왼쪽을 맞춘다      |
    | layout_alignParentRight/layout_alignParentEnd  | 부모 컨테이너의 오른쪽과 View의 오른쪽을 맞춘다  |
    | layout_centerHorizontal                        | 부모 컨테이너의 수평 방향 중앙에 배치한다        |
    | layout_centerVertical                          | 부모 컨테이너의 수직 방향 중앙에 배치한다        |
    | layout_centerInParent                          | 부모 컨테이너의 수평과 수직 방향 중앙에 배치한다 |

  - RelativeLayout  다른 View와의 상대적 정렬

    | 속성값                             | 정렬                                                    |
    | ---------------------------------- | ------------------------------------------------------- |
    | layout_above                       | 지정한 View의 위쪽에 배치한다                           |
    | layout_below                       | 지정한 View의 아래쪽에 배치한다                         |
    | layout_toLeftOf                    | 지정한 View의 왼쪽에 배치한다                           |
    | layout_toRightOf                   | 지정한 View의 오른쪽에 배치한다                         |
    | layout_alignTop                    | 지정한 View의 위쪽과 맞춘다                             |
    | layout_alignBottom                 | 지정한 View의 아래쪽과 맞춘다                           |
    | layout_alignLeft/layout_alignStart | 지정한 View의 왼쪽과 맞춘다                             |
    | layout_alignRight/layout_alignEnd  | 지정한 View의 오른쪽과 맞춘다                           |
    | layout_alignBaseline               | 지정한 View와 내용물의 아래쪽 기준선(Baseline)과 맞춘다 |

---

#### 02-4 TableLayout

- **TableLayout**(02-4, 139p) : 테이블 레이아웃이라고 부르며, 표나 엑셀의 시트와 같은 형태로 행과 열로 구성된 격자 모양의 화면을 구성하는 레이아웃이다
  - **TableRow**(02-4, 139p) : TableLayout 내부의 태그이며, 한 행을 의미한다
    - TableLayout 내부에는 여러 개의 TableRow가 포함되며, TableRow는 여러 개의 View를 포함한다. 이 View들은 각각 하나의 열이 된다.
      - TableRow의 개수 = 행의 개수, 각 TableRow마다 추가된 View의 개수 = 열의 개수
- **stretchColumns**(02-4, 140p) : 가로 방향으로 여유 공간이 있다면, 강제로 그 여유 공간까지 모두 채워서 column(열)을 설정한다
  - stretchColumns의 값은 해당 TableLayout의 열 인덱스를 기준으로 설정할 수 있다
    - 예를 들어, `android:stretchColumns="0, 2, 3"`은 TableLayout의 0, 2, 3번 째 인덱스에게 가로 방향의 여유 공간을 할당하여 세 View를 분할한다
      - 모든 인덱스의 값을 할당하려면, `"*"`을 사용한다

- **shrinkColumns**(02-4, 141p) : View의 가로 방향 폭이 넘친다면, 부모 Container의 폭에 맞추어 View의 폭을 강제로 축소한다
  - View의 폭을 축소하여 내용물이 넘친다면, TableRow의 높이를 자동으로 늘려준다
- **layout_column**(02-4, 141p) : layout_column 뒤에 인덱스의 번호를 입력하면, View가 해당 인덱스의 위치로 이동한다
- **layout_span**(02-4, 141p) : View가 지정한 인덱스의 크기만큼 여러 column에 걸쳐 View의 공간을 차지하게 한다

---

#### 02-5 FrameLayout

- **FrameLayout**(02-5, 142p) : FrameLayout 안에 View를 넣으면, 그 중 하나의 View만 화면에 표시한다
  - **Visibility**(02-5, 142p) : 가시성 속성이라고 부르며, 특정 View를 보이거나 보이지 않게 한다
- **ImageView**(02-5, 143p) : 이미지를 보여줄 때 사용하는 View이다

---

#### 02-6 ScrollView

- **ScrollView**(02-6, 146p) : 추가된 View의 영역이 화면에서 잘릴 때 사용한다
  - ScrollView를 추가하고 그 안에 View를 넣으면 수직 방향 스크롤이 생기게 된다

- **HorizontalScrollView**(02-6, 146p) : 수평 방향의 ScrollView이다

- **getDrawable**(02-6, 148p) : getDrawable 메서드는 Resources 객체에 정의되어 있으며, 소스 코드에 정의된 getResource 메서드를 이용하면 Resources 객체를 참조할 수 있다

- **getIntrinsicWidth**(02-6, 148p) : Image 객체의 원본 너비(가로) 크기를 구한다

- **getIntrinsicHeight**(02-6, 148p) : Image 객체의 원본 높이(세로) 크기를 구한다

- **setImageResource**(02-6, 148p) : 소스 코드에서 사용되며, ImageView에 사용할 이미지를 결정한다

- **setImageDrawable**(02-6, 148p) : 이미지 파일을 객체로 만든 후, ImageView에 설정할 때 사용한다
  - setImageDrawable 메서드를 사용하면 ImageView가 이미지의 크기를 화면 크기에 맞게 자동으로 줄인다









---



---

---

---



---



# 팁

## 01

### chap 03

#### 03-1

- **패키지 이름**(03-1, 29p) : 앱을 구분하는 고유한 값, 만든 앱이 단말에 설치되었을 때 다른 앱과 구분될 수 있는 역할을 한다
  - 다른 패키지 이름과 충돌하지 않게 지어주는 것이 중요하다
  - 실무에서는 패키지 이름을 중복되지 않는 인터넷 사이트 주소처럼 짓는 경우가 많다

---

#### 03-3

- 라이브러리의 변경(03-3, 38p) : 이전 버전의 안드로이드 개발과 비교하여, 안드로이드 스튜디오에서 자동적으로 만들어지는 앱의 외부 라이브러리가 바뀌었다. 대표적인 변경점은 다음과 같다.
  - support 라이브러리/AppCompat 라이브러리로 불리던 외부 라이브러리가 androidx로 변경되었다
    androidx 라이브러리는 안드로이드 최신 라이브러리들을 이전 단말기에서도 사용할 수 있도록 만들어주는 역할을 한다

- **import**(03-3, 45p) : 자바에서 라이브러리 패키지의 클래스를 사용할 때, import 구문을 사용하여 클래스 이름으로 사용할 수 있다
  - 안드로이드 스튜디오에서는 코드가 입력되었을 때 자동으로 필요한 import 구문을 넣을 수 있는 기능을 제공한다

---

#### 03-4

- **Constraint**(3-4, 49p) : 제약, 버튼의 위치를 결정하는 역할을 한다
  - Constraint가 없으면 버튼의 위치를 결정할 수 없기 때문에 오류가 발생한다
  - Design 화면에서 View를 선택하였을 때 테두리에 표시되는 동그라미들로 View들 사이의 연결선을 만들어 제약을 설정한다

- (3-4, 50p) : Design 화면에서 추가한 Button은 자동으로 id 속성 값이 입력된다

- (3-4, 50p) : Design 화면은 xml로 된 원본 코드를 미리보기 화면으로 보여준다
  - **Device For Preview 상자** : 미리보기 화면으로 볼 화면의 크기, 비율을 휴대전화 기종을 통해 선택할 수 있다



## 02

### chap 01

#### 01-2

- **상속**(01-2, 80p) : = java의 상속과 같은 개념이다
  - 자식 클래스가 부모 클래스의 속성을 물려받는 것이다

- 태그 지정(01-2, 82p)  : 

  - 태그 안의 속성들은 모두 공백이나 줄 바꿈으로 구별된다
  - *<OOOO*로 시작하여, */>*로 끝나는 경우, 해당 태그 내에 다른 태그 포함 불가
  - *<OOOO**>***로 시작하여, *</OOOO>*로 끝나는 경우, 해당 태그 내에 다른 태그 포함 가능

  ```
  <LinearLayout>					 //LinearLayout 시작
  							 	 //LinearLayout 범위
  <TextView 	//TextView 시작	    //LinearLayout 범위
  			//TextView 범위 		//LinearLayout 범위 
  /> 			//TextView 끝		//LinearLayout 범위
  								 //LinearLayout 범위
  </LinearLayout> 				 //LinearLayout 끝
  ```

- **android:**OOOO(01-2, 82p) : '안드로이드의 기본 API에서 정의한 속성'의 의미를 가지고 있다
  - 만약 사용자 정의 라이브러리 또는 외부 라이브러리(Third-party Library)를 사용했을 때, 그 안에 정의된 속성을 사용한다면, android:가 아닌 다른 단어(예 : app:)가 사용될 수 있다

### 01-3

- **Available Space**(01-3, 95p) : 해당 뷰가 차지할 수 있는 공간을 의미한다

- (01-3, 99p)위젯이나 레이아웃이 안드로이드 기본 API에 포함되어 있다면, 해당 위젯이나 레이아웃의 이름만 입력하면 되지만, 외부 라이브러리에서 불러온 것이라면 패키지 이름까지 같이 입력해야 한다
  - ConstraintLayout은 안드로이드 SDK에 나중에 추가되면서 외부 라이브러리로 분류되어 있다

- xmlns:접두어(01-3, 99~100p)
  - xml 레이아웃 파일이라면 한 번씩 넣어주어야 하는 속성이며, xmlns:뒤의 내용이 나머지 속성의 지정된 정보를 참조하는 접두어로 사용된다
    - xmlns:android
      - 안드로이드 기본 SDK에 포함되어 있는 속성을 사용한다
    - xmlns:app
      - 프로젝트에서 사용하는 외부 라이브러리에 포함되어 있는 속성을 사용하며, app이라는 단어는 다른 단어로 바뀔 수 있다
    - xmlns:tools
      - 안드로이드 스튜디오의 디자이너 도구 등에서 화면에 보여줄 때 사용하며, 앱이 실행될 때는 적용되지 않는다

### chap 02

#### 02-2

- ​	(02-2, 119p)보통 xml 파일로 Layout을 구성하지만, 동적인 Layout 구성을 위해서는 자바 소스 코드에서 화면 레이아웃을 구성해아 할 수 있다
- **this**(02-2, 120p) : 주로 생성자와 메소드의 매개변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시할 때 사용한다

- (02-2, 122p)xml 레이아웃 파일에서 정의할 수 있는 대부분의 속성은 자바 소스 코드에서도 사용할 수 있도록 메서드로 제공된다

- **context**(02-2, 123p) : 객체의 정보를 담고 있는 객체를 의미한다
  -  객체를 처리하기 위한 접근 수단, 공항에서 사용하는 여권처럼 신분증과 비슷한 의미이다
  - View에 대한 정보를 손쉽게 확인하거나 설정할 수 있도록 View의 생성자에 Context 객체를 전달한다

- **Root element**(02-2, 124p) : 새로운 xml(레이아웃)파일을 생성할 때 추가하는 옵션이며, 최상위 레이아웃을 어떤 것으로 지정할 것인지를 xml 파일을 생성하는 과정에서 설정할 수 있다.

---

#### 02-4 TableLayout

- **TableRow**의 크기(02-4, 139p)
  - TableLayout 내부에 포함된 TableRow의 높이 값은 내부적으로 항상 `wrap_content`로 설정되어 있어 화면을 꽉 채울 수 없다
  - TableRow의 폭은 내부적으로 항상 `match_parent`로 설정되어 있어 가로 공간을 꽉 채운다
  - 이와 같은 TableRow의 속성은 각 TableRow를 하나의 행으로 표시될 수 있도록 만들기 위함이다

---

#### 02-6 ScrollView

- 이미지 파일의 이름(02-6, 146p) 
  - `\app\res\drawable` 폴더 안에 이미지 파일을 넣을 때, 파일 이름에 대문자가 포함되어 있거나 파일 이름이 숫자로 시작하면 오류가 발생한다

- (02-6, 146p) : HorizontalScrollView를 추가한 후 ScrollView를 추가하면 수직, 수평 방향 모두 스크롤 할 수 있다
